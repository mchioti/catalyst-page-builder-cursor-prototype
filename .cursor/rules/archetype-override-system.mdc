---
description: Guidelines for working with the archetype/page instance inheritance system and zone overrides
globs: ["src/**/*.tsx", "src/**/*.ts"]
alwaysApply: false
---

# Rule: Archetype & Page Instance Override System

## Architecture Overview

This codebase implements a **master template inheritance system** where:
- **Masters (Archetypes)** are master templates (e.g., "Modern Journal Home") that define default content for zones
- **Page Instances** can sync with Masters and override specific zones locally
- Changes to Masters propagate to all synced pages (unless those zones have local modifications)

## Terminology (User-Facing)

| Internal Term | User-Facing Term | Description |
|---------------|------------------|-------------|
| Archetype | **Master** | Source of truth template |
| Stub | **Copy** | One-time snapshot, no sync |
| Inherited | **ðŸ”— Synced** | Following the Master |
| Overridden | **âœï¸ Modified** | Has local changes |
| Push to Archetype | **Push to All [Journals]** | Update Master (contextual) |
| Keep Local | **Keep for This [Journal]** | Save as modification (contextual) |
| Reset to Archetype | **Sync with Master** | Remove modifications |

### Contextual Labels (displayLabel)

Archetypes have a `displayLabel` property for contextual language:
```typescript
archetype: {
  displayLabel: { singular: 'Journal', plural: 'Journals' }
}
```

This enables:
- "Push to All **Journals**" (for Journal Home archetype)
- "Push to All **Issues**" (for Issue ToC archetype)
- "Keep for This **Article**" (for Article archetype)

## Inheritance Decision: At Use Time

**Key Design Decision:** The choice between Copy vs Synced happens when USING a saved design, not when saving it.

### When Creating/Applying a Page Design:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ How would you like to use "Modern Journal Home"?    â”‚
â”‚                                                     â”‚
â”‚ â—‹ Start as Copy                                     â”‚
â”‚   (Independent - no sync with original)             â”‚
â”‚                                                     â”‚
â”‚ â—‹ Sync with Master                                  â”‚
â”‚   (Stays synced - receives updates)                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### For Existing Pages (Link to Master):
- Show preview/diff of what will change
- User can cherry-pick which zones to sync vs keep
- Draft/Preview mode before committing

### Any Page Can Sync with Any Master
- Not limited to journal homepages
- Homepage, About, Contact can all sync with Masters
- Enables managing 10+ websites with consistent templates

```
Archetype (Master Template)
  â””â”€â”€ zones: { hero: [...], content: [...], sidebar: [...] }
  
PageInstance (Individual Page)
  â””â”€â”€ archetypeId: "modern-journal-home"
  â””â”€â”€ overrides: { hero: [...] }  // Only overridden zones stored
  â””â”€â”€ overrideHistory: { hero: [{ snapshot, description, timestamp }] }
```

## Key Concepts

### Zone-Based Inheritance
- Pages inherit ALL zones from their archetype by default
- Only overridden zones are stored in `PageInstance.overrides`
- `resolveCanvasFromArchetype()` merges archetype zones + local overrides

### Override History
Each zone tracks its change history for undo/revert functionality:

```typescript
interface OverrideHistoryEntry {
  snapshot: WidgetSection[]  // State at time of override
  description: string        // Human-readable change description
  timestamp: number
}

interface PageInstance {
  overrides: { [zoneSlug: string]: WidgetSection[] }
  overrideHistory: { [zoneSlug: string]: { entries: OverrideHistoryEntry[] } }
}
```

## Critical: Dirty Zone Calculation

### âŒ WRONG: Compare against raw archetype
```typescript
// BAD - will flag committed local changes as "dirty" again
const dirtyZones = compareSections(currentCanvas, archetype.zones)
```

### âœ… CORRECT: Compare against committed state (archetype + overrides)
```typescript
// GOOD - only new changes are flagged as dirty
const committedState = resolveCanvasFromArchetype(pageInstance)
const dirtyZones = compareSections(currentCanvas, committedState)
```

This prevents the system from re-asking about changes that were already saved as local overrides.

## Canvas Ownership Pattern

### The Problem
When navigating between pages, stale canvas content from the previous page can pollute the editor, causing:
- Wrong content displayed
- Changes saved to wrong page
- False "unsaved changes" indicators

### The Solution: `canvasOwnerId`

```typescript
// In pageStore.ts
canvasOwnerId: string | null  // Tracks which page owns current canvasItems

// In PageBuilderEditor - set when loading content
setCanvasOwnerId(`${websiteId}:${pageName}`)

// In PageBuilder - only track changes for owned content
const currentOwnerId = `${websiteId}:${pageName}`
if (canvasOwnerId !== currentOwnerId) {
  return  // Don't track changes for stale content
}
```

### Lifecycle Hooks

Use `useLayoutEffect` (not `useEffect`) for synchronous canvas clearing on page switch:

```typescript
// Clear stale content BEFORE render
useLayoutEffect(() => {
  if (isPageSwitch) {
    setCanvasItems([])  // Synchronous clear
    setCanvasOwnerId(null)
    isTransitioningRef.current = true
  }
}, [pageKey])
```

## Draft Management

### Storage Hierarchy (Priority Order)
1. `pageDraftData` (sessionStorage + in-memory) - Unsaved edits
2. `pageCanvasData` (in-memory) - Last published state
3. `PageInstance` resolved from archetype - Committed overrides
4. Raw archetype zones - Default content

### Critical: Clear Drafts When Propagating Archetype Changes

When saving an archetype or promoting content to archetype:

```typescript
// Clear drafts for ALL affected pages so they pick up new archetype content
affectedPages.forEach(page => {
  clearPageDraft(page.websiteId, page.pageName)
  clearPageCanvas(page.websiteId, page.pageName)
})
```

Without this, pages with existing drafts won't see archetype updates.

## Key Store Functions

### archetypeStore.ts
- `resolveCanvasFromArchetype(pageInstance)` - Merge archetype + overrides
- `overrideZone(pageInstanceId, zoneSlug, sections, description)` - Save local override
- `inheritZone(pageInstanceId, zoneSlug)` - Revert zone to archetype
- `undoZoneOverride(pageInstanceId, zoneSlug)` - Undo last change
- `resetPageToArchetype(pageInstanceId)` - Clear all overrides

### pageStore.ts
- `setCanvasOwnerId(ownerId)` - Track canvas ownership
- `clearPageDraft(websiteId, pageName)` - Clear draft data
- `clearPageCanvas(websiteId, pageName)` - Clear published cache

## Publish Flow

When user clicks "Save & Publish":

1. **Calculate dirty zones** (compare current vs committed state)
2. **Show PublishReviewModal** with choices per zone:
   - "Keep for This [Journal]" â†’ `overrideZone()` saves as modification
   - "Push to All [Journals]" â†’ Updates Master, clears modification
   - "Discard" â†’ Reverts zone to previous state
3. **Grouped display:**
   - "Syncing with Master" group â†’ Zones being reset (show Confirm Sync / Keep Modified)
   - "New Changes" group â†’ Zones with new edits (show full options)
4. **Clear caches** after publish:
   ```typescript
   clearPageDraft(websiteId, pageName)
   clearPageCanvas(websiteId, pageName)
   ```

## Role-Based Access (Phase 2)

Future implementation will enforce:
- **Platform Admin**: Can push to all, create Masters, edit any zone
- **Publisher**: Can push to their portfolio, create Masters for their journals
- **Journal Manager**: Can only modify their journal (no push to others)
- **Content Editor**: Can only edit specific content zones

Zone tiers (`locked` property) will control editability per role.

## Common Pitfalls

### 1. Race Conditions on Navigation
- Always use `isTransitioningRef` to block draft saves during page switch
- Clear canvas synchronously with `useLayoutEffect`

### 2. Stale Content Detection
- Don't use content heuristics (e.g., "does this look like journal content?")
- Use explicit `canvasOwnerId` matching instead

### 3. Forgetting to Clear Caches
- After archetype save â†’ clear all inheriting pages' drafts
- After local override save â†’ clear that page's draft AND pageCanvasData

### 4. Comparing Against Wrong Baseline
- For "dirty" detection: compare against committed state (archetype + overrides)
- For "promote to archetype": compare against raw archetype zones

## Key Files
- `src/stores/archetypeStore.ts` - Archetype/PageInstance CRUD and resolution
- `src/stores/pageStore.ts` - Canvas state, drafts, ownership tracking
- `src/components/PageBuilderEditor/index.tsx` - Page loading and ownership
- `src/components/PageBuilder/index.tsx` - Editing and publish flow
- `src/utils/zoneComparison.ts` - Dirty zone detection
- `src/types/archetypes.ts` - Type definitions

## Debug Logging
Enable debug mode in key files when troubleshooting:
```typescript
const DEBUG = true  // In PageBuilderEditor, PageBuilder, zoneComparison
```

Look for:
- `[PageBuilderEditor]` - Content loading decisions
- `[PageBuilder]` - Change tracking and publish flow
- `[archetypeStore]` - Override saves and resolutions
